<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Wangdaiwei's San Siro</title><link href="http://wangdaiwei.github.io/" rel="alternate"></link><link href="http://wangdaiwei.github.io/feeds/all.atom.xml" rel="self"></link><id>http://wangdaiwei.github.io/</id><updated>2014-05-22T00:00:00+08:00</updated><entry><title>用WebGL编写一个3D图形网站</title><link href="http://wangdaiwei.github.io/posts/2014/May/22/yong-webglbian-xie-ge-3dtu-xing-wang-zhan/" rel="alternate"></link><updated>2014-05-22T00:00:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2014-05-22:posts/2014/May/22/yong-webglbian-xie-ge-3dtu-xing-wang-zhan/</id><summary type="html">&lt;p&gt;自己的学生生涯也差不多结束了，感觉是时候把自己这一年来学的东西做一个总结，顺便回顾一下以前做过的东西。这几天多动动手，争取写多一些内容。&lt;/p&gt;
&lt;h2&gt;WebGL简单介绍&lt;/h2&gt;
&lt;p&gt;如果有听说过OpenGL的话，那么WebGL理解起来就不是那么困难了，简单来说其实就是OpenGL在HTML5的JavaScript移植版。要是OpenGL没听说过，那就把它当成是一个在网页上的图形引擎吧。我们可以在HTML5的网页上创建Canvas（画布）来配置我们的WebGL绘制图形的过程。&lt;/p&gt;
&lt;p&gt;要想从最基本的开始写一个很简单的程序也不是那么容易的，写过OpenGL程序的人肯定都知道，想要显示一个简单的正方形也不是一句代码就能解决的事。你得设置好视角，然后你得定义绘图方式，标出矩形每一个顶点的位置，再转换到世界坐标系等等。总之就是一切都是计算机图形学基础的东西，要想好好用WebGL这个写一个能看的动画估计就得花好长时间了。所以我们还是用点现成的东西吧，目前关于WebGL可用的库有很多，比较常用的就是Three.js。&lt;/p&gt;
&lt;h2&gt;Three.js&lt;/h2&gt;
&lt;p&gt;这个库已经写的比较完整了，已经有很多很炫的例子，可以在&lt;a href="http://threejs.org/"&gt;官网&lt;/a&gt;上找到。有了Three.js，很多事情变简单了许多。绘制一个3D画面的步骤就变成这样了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;、在&lt;/span&gt;&lt;span class="n"&gt;HTML&lt;/span&gt;&lt;span class="err"&gt;网页里配置基本的画布&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;、在画布上布置&lt;/span&gt;&lt;span class="n"&gt;WebGL&lt;/span&gt;&lt;span class="err"&gt;基本元素，比如立方体，球体等等&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="err"&gt;、配置好&lt;/span&gt;&lt;span class="n"&gt;Camera&lt;/span&gt;&lt;span class="err"&gt;（照相机？总觉得怪怪的）加入光源，着色器等等&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;、如果需要的话，加入对输入设备的检测，比如鼠标的点击动作&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="err"&gt;、最后就是加入一个计时器不断地刷新页面，比如动态显示水面的波纹，需要随时更新水平面上点的新的法面向量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在我们已经不需要考虑物体中每一个点的坐标变换，我们可以对整个物体进行旋转平移操作。我们也不需要编写着色器来为每一个顶点着色，设置缓存来计算每一顶点的RGB值。&lt;/p&gt;
&lt;h2&gt;前期准备&lt;/h2&gt;
&lt;p&gt;首先当然是把Three.js库下载下来，可以在Github上找到&lt;a href="https://github.com/mrdoob/three.js/"&gt;https://github.com/mrdoob/three.js/&lt;/a&gt;，也可一在&lt;a href="http://threejs.org/docs/index.html#Manual/Introduction/Creating_a_scene"&gt;官网的教程&lt;/a&gt;上下载到。我们只需要three.min.js文件就够了。&lt;/p&gt;
&lt;p&gt;创建一个html文件，把下面的内容粘贴进去：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;My first Three.js app&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;style&amp;gt;&lt;/span&gt;canvas { width: 100%; height: 100% }&lt;span class="nt"&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;js/three.min.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
            // Our Javascript will go here.
        &lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;创建场景&lt;/h2&gt;
&lt;p&gt;接下来我们要在script标签里面创建我们的场景，我们需要获取到网页窗口的大小然后告诉给渲染器&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;scene&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;THREE&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Scene&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;camera&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;THREE&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PerspectiveCamera&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mi"&gt;75&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;innerWidth&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;innerHeight&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;renderer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;THREE&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WebGLRenderer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;renderer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;innerWidth&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;innerHeight&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;renderer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;domElement&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在这里选择了投影变换的Camera，另外一种情况是正交投影的Camera，一般只在CAD工具里面会用到。&lt;/p&gt;
&lt;p&gt;THREE.PerspectiveCamera里面的参数有四个。第一个是视角范围，这里是75度的夹角。第二个是视角比例，就是长宽比，设置成这样的值可以保证接下来创建的物体不变形，如果需要拉伸整个场景的长度或者宽度的话才需要修改这个值。&lt;/p&gt;
&lt;p&gt;第三个和第四个值分别表示近平面和远平面的距离，这两个值决定了小于和大于多少的距离的物体会被剔除出视野外。近平面一般都设置得比较小，但绝对不能是零，因为当计算物体大小得时候是按照和Camera原点的距离比值计算的，当无限接近于Camera原点的时候物体的大小会变成无穷大。&lt;/p&gt;
&lt;p&gt;渲染器需要知道它需要渲染的窗口大小，因此在这里设置成整个网页窗口。我们需要把设置好的元素加入到html里面。&lt;/p&gt;
&lt;p&gt;接下来让我们创建一个立方体：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;geometry&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;THREE&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CubeGeometry&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;material&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;THREE&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MeshBasicMaterial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0x00ff00&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;cube&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;THREE&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Mesh&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;material&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;scene&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;cube&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;camera&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们只需要调用CubeGeometry方法就能创建一个立方体形状，同时我们需要配置这个立方体的外观，这里用MeshBasicMaterial创建，这是一个单色的材质。每一个添加到场景的物体都需要形状和材质创建，这样我们就生成了一个Mesh。&lt;/p&gt;
&lt;p&gt;这里Camera的位置被设置成了（0，0，5），假如仍然在原点的话，网页是无法显示这个立方体的，因为Camera被放置在了立方体内部。&lt;/p&gt;
&lt;h2&gt;场景渲染&lt;/h2&gt;
&lt;p&gt;这时候我们的网页还不能显示任何东西，因为关键的渲染步骤还没有完成，我们要让网页自己定时刷新页面来显示图形。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;render&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;requestAnimationFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;render&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nx"&gt;renderer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;render&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;scene&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;camera&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;render&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;requestAnimationFram函数会在用户切换到其他页面时停止刷新当前页面。&lt;/p&gt;
&lt;h2&gt;让立方体动起来&lt;/h2&gt;
&lt;p&gt;这时候打开网页，看到的只是在黑色背景里面一个绿色的正方形。因为是正对着立方体看的，所以看不出有任何的3D效果。我们可以让立方体动起来观察它，在render函数里面加入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cube&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rotation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;cube&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rotation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们就可以在网页里看到一个疯狂转动的立方体了。&lt;/p&gt;
&lt;h2&gt;完整代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;My first Three.js app&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;style&amp;gt;&lt;/span&gt;canvas { width: 100%; height: 100% }&lt;span class="nt"&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;js/three.min.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            var geometry = new THREE.CubeGeometry(1,1,1);
            var material = new THREE.MeshBasicMaterial({color: 0x00ff00});
            var cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            camera.position.z = 5;

            var render = function () {
                requestAnimationFrame(render);

                cube.rotation.x += 0.1;
                cube.rotation.y += 0.1;

                renderer.render(scene, camera);
            };

            render();
        &lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;可能遇到的问题&lt;/h2&gt;
&lt;p&gt;如果打开网页看到空白的页面，那是因为浏览器关闭了访问本地文件的权限，或者是three.min.js放置在了错误的目录。一定要保证three.min.js放置在html文件目录下的js文件夹内。想要避开浏览器对访问本地文件的限制，可以配置chrome绕开限制，或者在目录下开启一个http服务器。如果电脑有安装python，只需要在该目录下输入指令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;python&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;SimpleHTTPServer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果是python3的话&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;python3&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;其他&lt;/h2&gt;
&lt;p&gt;上面的内容主要来自Three.js官方教程，请参考网址&lt;a href="http://threejs.org/docs/index.html#Manual/Introduction/Creating_a_scene"&gt;http://threejs.org/docs/index.html#Manual/Introduction/Creating_a_scene&lt;/a&gt;。如果想了解WebGL，可以学习&lt;a href="http://learningwebgl.com/blog/?page_id=1217"&gt;WebGL教程&lt;/a&gt;。想了解OpenGL，可以学习比较常用的&lt;a href="http://nehe.gamedev.net/"&gt;NeHe系列教程&lt;/a&gt;，NeHe系列已经有中文版了。&lt;/p&gt;</summary><category term="WebGL"></category></entry><entry><title>在香港求学的日子</title><link href="http://wangdaiwei.github.io/posts/2014/Feb/22/zai-xiang-gang-qiu-xue-de-ri-zi/" rel="alternate"></link><updated>2014-02-22T00:00:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2014-02-22:posts/2014/Feb/22/zai-xiang-gang-qiu-xue-de-ri-zi/</id><summary type="html">&lt;p&gt;早就说要写点有关香港这段日子的东西，一直没有提笔。难得前段时间把网站的架构重新整理了一下，修复了一点bug。趁此机会就写点感悟吧。主要还是针对在CUHK的学习方面。&lt;/p&gt;
&lt;h2&gt;初到香港&lt;/h2&gt;
&lt;p&gt;作为一个土生土长的广东人来说，香港一直在我眼里停留在电视上播的各种电视剧上，也多亏了这一点我才能听得懂并且勉强能讲一下粤语。实际去的时候肯定还是和电视上有很大不同，比如说香港的地铁实在是太旧了，感觉和北京的十三号线有的一拼，不过这是东铁线的情况。&lt;/p&gt;
&lt;p&gt;然后就是紧张的签合同买家具的过程了。幸亏是在红磡，楼下就有家居市场，但是符合我们理想价位的店实在不多。也就是从买家具的时候开始，我们认识到了香港的物价水平略微有点高，于是没钱就成了我们生活的主旋律。&lt;/p&gt;
&lt;h2&gt;香港对于留学生的意义&lt;/h2&gt;
&lt;p&gt;我觉得生活方面实在是没什么可写的了，还是讲讲留学香港的东西吧，正好之前也有人问我这方面的事。首先要说的一点就是学位的事情，香港这里的学位主要分为三种：PhD，MPhill，MSc，这是针对工科的。因为PhD和MPhill要套瓷，还可能要写点research proposal之类的，对于主要想读个硕士的人来说可能不太合适，很多人更关注MSc的含金量。因为本人也是读的MSc，我想讲一讲我的看法。&lt;/p&gt;
&lt;p&gt;对于大部分专业的full time MSc来说，一般课程只需要上一年，然后在次年的年底拿到毕业证。于是在课程结束的5月，或者如果有summer term的话就是7月，一直到拿毕业证的12月之间都是没有课的。加上办理留服的学位认证，可能这些东西要到毕业第二年的1月才能拿齐。所以在找工作的时候一般会有两种选择，在还没毕业的时候说自己是5，6月毕业的，或者是在课程结束后说自己是年底12月毕业。毕业日期主要是写给企业看的，前者着重说明自己在5月以后就能开始工作，后者说明自己可以在12月拿到毕业证，都没有什么问题。并且国家对于留学生回国就业的政策，在两年内没有工作的话是不区分应届不应届的（这个我是仅凭记忆写下来的，最好找一找最新的政策确认一下）。所以其实对于来到香港的学生来说，回国就业也并不是那么难。&lt;/p&gt;
&lt;p&gt;但是网上可能有些说法说香港的学位含金量下降了，对于找工作意义不大甚至还有负面作用。诚然，香港最近是一直在扩招内地的学生，不仅是MSc包括本科也在扩招。随着人越来越多，难免有些基础不够扎实的，于是这些人就开始批评MSc了。MSc对于那些如果只是想来镀金的人来说，恐怕不是一个合适的选择。&lt;/p&gt;
&lt;h2&gt;和内地的区别&lt;/h2&gt;
&lt;p&gt;从入学的时候开始，CUHK的邮箱就不断有邮件提示Job fair和讲座的信息，这些资源在国内绝对是很难见得到的。并且由于交了学费，学院还送给我们每个月500个打印的quota，三个计算机机房，还有好几个Linux服务器。要是来读本科，可能待遇还会更好，我们实验室一个善衡书院的学生每周二到周四都有学院的聚餐，把整个饭堂包场。要是一个个展开来说的话可能就太啰嗦了，接下来就说一下学校的课程。&lt;/p&gt;
&lt;h2&gt;中大的课程&lt;/h2&gt;
&lt;p&gt;计算机方面的课程，分为两个类型：CMSC和CSCI。前者是晚上针对MSc专门开的，偏向应用，所以你可以看到几乎所有的part time和大部分local都会选晚上的课。后者是和PhD和MPhill一起上，偏研究，主要是在白天上课。选课方面小米给的建议是一个学期不要选两门以上的CSCI，我第一学期不自量力地选了三门，所以当时就被虐惨了。这学期就很干脆地选了三门CMSC的课。授课语言都是英语，除了讲machine learning的大神Lei Xu一直在用普通话授课。&lt;/p&gt;
&lt;p&gt;如果说想来申请CUHK的PhD或者MPill的话，可以考虑申请Computer Graphics方向。T.T Wong在这方面很牛，当然是指授课方面，学术听说也不差。Dr. Heng是我选的project的instructor，但基本没管过我们，也没管过他的PhD，基本上已经处于修身养性的状态。要是想搞纯理论的话可以考虑Lei Xu，不过十年内他只招了三个学生，还不知道毕业了几个。不过他应该是我们学院在学术方面最NB的老师了吧。还有一个我很喜欢的老师Jimmy Lee，研究组合优化方向，对学生要求很严，但从他身上能学到很多东西。感觉Data mining方向在CUHK做的不是很多，King本人感觉比较水，但又老喜欢push学生。Micheal中规中矩吧。Yufei Tao还是挺不错的，讲课很棒。&lt;/p&gt;
&lt;h2&gt;题外话&lt;/h2&gt;
&lt;p&gt;虽然能用上1Gbps带宽的网，但你能体会到连优酷都会卡的感受吗！&lt;/p&gt;</summary><category term="CUHK"></category></entry><entry><title>ABC Path Problem Definition</title><link href="http://wangdaiwei.github.io/posts/2014/Feb/20/abc-path-problem-definition/" rel="alternate"></link><updated>2014-02-20T00:00:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2014-02-20:posts/2014/Feb/20/abc-path-problem-definition/</id><summary type="html">&lt;h1&gt;ABC Path Problem Definition&lt;/h1&gt;
&lt;p&gt;ABC Path is a game that you have to put into the N $\times$ N grid such that the total payoff of the game is maximized. If a letter is placed on the desired position, it gets 1 as payoff. Here is an example for the desired position of each letter for a $4 \times 4 $ grid.￼&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;th&gt;D&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;J&lt;/td&gt;
&lt;td&gt;K&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;And the rule is the same for other N values. It follows the alphabetic order from the upper left to the bottom right.&lt;/p&gt;
&lt;p&gt;We can model the problem with a set of 16 variables $X =$ { $x_i, j| i, j ∈ [1..4]$ }, each representing a cell of the grid. The domain of each variable $x_i,j$ is $D_i,j =$ {$ 1, 2, .., 16$ } with each value representing the letter in { $A,B,..,P$ } respectively. Let $S_i,j$ be the set of all adjacent cells of $x_i,j$. The set of constraints and the associated objective function of the problem are given as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$(x_{i,j} =1)∨ ( \bigvee _{s \in S_{i, j}} x_{i,j} =s+1 ) ,$ for $i,j∈[1..4]$&lt;/li&gt;
&lt;li&gt;$x_{i,j} \ne x_{u,v},$ for $i,j,u,v∈[1..4]$ where $¬(i=u∧j=v)$&lt;/li&gt;
&lt;li&gt;Objective: max $\sum_{i,j \in [1...4]} (x_{i,j} −(4i+j −4) == 0)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An alternative way to model the problem is to represent each letter with a variable $x_i$ , where $i ∈ [1..n2 ]$ and the domain of each variable $x_i$ is $D_i =$ { $1, 2, ..., n2$ } representing the position of the corresponding letter in the grid.&lt;/p&gt;
&lt;p&gt;The Gecode implementation has been uploaded to my github repository. You can see the source code at website &lt;a href="https://github.com/wangdaiwei/gecode"&gt;wangdaiwei/gecode&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The program should be run as following command in Mac OSX:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;abc_path&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="n"&gt;mod&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here &lt;em&gt;mod&lt;/em&gt; stands for the model you choose. The value is from 1 to 2, which represents the memtioned models. The last parameter defines the size of ABC Path problem.&lt;/p&gt;</summary><category term="CSP"></category></entry><entry><title>N-Queens Problem Definition</title><link href="http://wangdaiwei.github.io/posts/2014/Feb/20/n-queens-problem-definition/" rel="alternate"></link><updated>2014-02-20T00:00:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2014-02-20:posts/2014/Feb/20/n-queens-problem-definition/</id><summary type="html">&lt;h1&gt;N Queens Problem Definition&lt;/h1&gt;
&lt;p&gt;N-Queens problem is defined as: place n queens on an $n × n$ chess board so that the queens do not attack each other. Now, we rotate the board clockwisely by 45 degrees as shown in following picture, and use a variable to denote the queen partition (if any) for each row (a diagonal in the original board).&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 1" src="https://raw.github.com/wangdaiwei/gecode/master/queens.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Thus the variables are $y_{1-n}, y_{2-n},..., y_{0},..., y_{n-2}, y_{n-1}.$ While each variable takes values according to the new coordinate system, we use the value $−n$ to denote that there are no queens on a particular row. The domain of each variable $y_i$ is thus $ D_i = $ { $|i|+1,|i|+3,...,2n−|i|−1$ } $∪$ {$−n$} for $i ∈ [1−n,n−1] $. The set of constraints are given as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for $i∈[1−n,n−1]$: $\sum_i(y_i \ne−n)=n$&lt;/li&gt;
&lt;li&gt;for $i∈[1−n,n−1]$ and $j∈[1,2n−1]: \sum_i(y_i =j)≤1$&lt;/li&gt;
&lt;li&gt;for $i,j∈[1−n,n−1]$ and $i \ne j:|y_i−y_j| \ne |i−j|$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The model is modeled in three ways: arithmetic constraint, tuple sets and DFA.&lt;/p&gt;
&lt;p&gt;The Gecode implementation has been uploaded to my github repository. You can see the source code at website &lt;a href="https://github.com/wangdaiwei/gecode"&gt;wangdaiwei/gecode&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The program should be run as following command in Mac OSX:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;queens&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="n"&gt;mod&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here &lt;em&gt;mod&lt;/em&gt; stands for the model you choose. The value is from 1 to 3. The last parameter defines the size of N-Queens problem.&lt;/p&gt;</summary><category term="CSP"></category></entry><entry><title>Sudoku Problem Definition</title><link href="http://wangdaiwei.github.io/posts/2014/Feb/20/sudoku-problem-definition/" rel="alternate"></link><updated>2014-02-20T00:00:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2014-02-20:posts/2014/Feb/20/sudoku-problem-definition/</id><summary type="html">&lt;h1&gt;Sudoku Problem Definition&lt;/h1&gt;
&lt;p&gt;Sudoku is a puzzle that requires players to complete a partially filled 9 × 9 grid with digits 1 to 9 such that each row, each column and each of the nine 3 × 3 boxes (shown in Figure 1 in thick border lines) contain different digits.&lt;/p&gt;
&lt;p&gt;￼￼￼The Gecode implementation has hardcoded the sudoku problem. You can modify the sudokuArray in order to solve different sudoku problems.&lt;/p&gt;
&lt;p&gt;The Gecode implementation has been uploaded to my github repository. You can see the source code at website &lt;a href="https://github.com/wangdaiwei/gecode"&gt;wangdaiwei/gecode&lt;/a&gt;.&lt;/p&gt;</summary><category term="CSP"></category></entry><entry><title>理解Hadoop和MapReduce</title><link href="http://wangdaiwei.github.io/posts/2014/Jan/25/li-jie-hadoophe-mapreduce/" rel="alternate"></link><updated>2014-01-25T00:00:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2014-01-25:posts/2014/Jan/25/li-jie-hadoophe-mapreduce/</id><summary type="html">&lt;h2&gt;为什么需要用到Hadoop&lt;/h2&gt;
&lt;p&gt;Hadoop是Apache开源基金会下的一个项目，针对处理大数据的特性设计的分布式编程模型工具。Hadoop的核心思想来源于Google的MapReduce和Google File System（GFS）。通俗来讲，就是将处理的问题分为两个子问题，一个负责将问题分割成一个一个小的部分，另一个负责将前一个步骤的每一部分都合并在一起。&lt;/p&gt;
&lt;p&gt;最常见的例子就是单词统计。假设我们需要统计一个文档里的单词，最简单的方式就是用一个dictionary或者map来存储一个key-value对。一旦发现一个新的单词，我们就在这个dictionary里面添加一个条目，value设为1。如果这个单词已经存在，那么取出这个key对应的value，将其加1。这种方式对于一个小的文档来说固然合适，但如果我们处理的是一个TB，PB级别的数据呢？如果我们想在1秒钟之内就处理完这些数据？这就需要用到分布式处理了，也就是多台机器同时运算。对于数单词这样一个简单的工作，要解决的就是如何分配任务，每一台机器需要处理文档的哪个部分，以及如何将这些结果整合在一起。有了这样的思想，我们可以给这两个部分的工作分配给两个模块，一个是mapper，一个是reducer。mapper负责把问题分割成很小的一部分，每一部分都会产生一个问题的输出；reducer负责把所有若干个mapper产生的输出汇总，再计算出所需的输出。由于这种模型涉及到的数据量都比较大，而建立在大数据上的数据处理一般来说都相对比较简单，因此将这种模型一般化，使用户只需要关注mapper和reducer的具体实现，而不用考虑异常处理，问题分割等等细节问题，这就是Hadoop需要解决的问题。&lt;/p&gt;
&lt;p&gt;但是，并不是所有问题都适合用MapReduce模型解决，比如说PageRank。当问题涉及到图结构的时候，一个很普遍的现象就是活跃节点和不活跃节点差异非常明显。比如说Yahoo网页的PageRank值要计算很多次才能收敛，因为它链接的网页实在是太多了。而小一点的网站可能一下子就收敛了，因为其本身链接的网站并不多，也并没有很高的影响力。而且在图问题中，绝大部分的节点都是不活跃的，也就是说可能整个MapReduce计算一次，只有少数几个节点的值发生了变化，这严重影响到了处理时间。Google针对这个问题提出了Pregel模型，GraphLab就是参考这个模型实现的，相关的论文里面可以看出在PageRank和三角形计数算法上GraphLab完胜基于MapReduce的Hadoop。&lt;/p&gt;
&lt;h2&gt;理解Mapper和Reducer&lt;/h2&gt;
&lt;p&gt;如果只从输入输出来看，mapper和reducer的输入输出都是一个key-valud对。当然，具体实现来说key和value并不是必须的，比如说统计所有文档的单词数，mapper的输入就可以是key：文件名，value：文件内容，文件名在这里不需要用到。&lt;/p&gt;
&lt;p&gt;对于数单词这个问题，mapper需要做的就是把自己负责的那部分文档的单词都统计出来，输出key-value对。这里的key就是单词，value就是1，代表的含义就是在这部分的文档中这个单词出现了1次。当然，也可以在mapper里面就把所有重复的单词都统计一次，汇总之后再设为这个单词key的value。而reducer就会收到mapper的单词key-value对。假如一开始mapper输入的文档内容是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么mapper的输出就是如下形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时reducer接收到的输入是按照key排列号的，因此实际上reducer的输入是如下的顺序输入的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;于是实际上reducer可以这么写，这里用伪代码实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
    &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;foreach&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;vals&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
    &lt;span class="n"&gt;emit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样得到的最终reducer的输出应该是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;具体实现&lt;/h2&gt;
&lt;p&gt;鉴于网上hadoop的教程都比较多，就不在这里写出来了，用Python实现的可以参考&lt;a href="http://www.michael-noll.com/tutorials/writing-an-hadoop-mapreduce-program-in-python/"&gt;Writing an Hadoop MapReduce Program in Python&lt;/a&gt;，还有用Java实现的例子：&lt;a href="http://www.cnblogs.com/xia520pi/archive/2012/06/04/2534533.html"&gt;Hadoop集群（第9期）_MapReduce初级案例&lt;/a&gt;。&lt;/p&gt;</summary><category term="Mapreduce"></category></entry><entry><title>Constraint Satisfaction Problem</title><link href="http://wangdaiwei.github.io/posts/2014/Jan/07/constraint-satisfaction-problem/" rel="alternate"></link><updated>2014-01-07T00:00:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2014-01-07:posts/2014/Jan/07/constraint-satisfaction-problem/</id><summary type="html">&lt;h2&gt;CSP概述&lt;/h2&gt;
&lt;p&gt;作为对学了一个学期的内容的总结，在这里稍微介绍一下Constraint Satisfaction Problem（CSP）吧。这个题目我也不知道中文叫做什么，也许叫做有约束问题解决模型比较合适。虽然我没有学过数学建模，但或许他们之间是比较类似的，CSP的中心思想就是针对一个特定的问题建立模型，然后解决它。解决问题的具体实现就叫做Constraint Solver（约束处理机）。我认为这个方法还是很实际的，它可以帮助我们快速建立起对一个问题的数学角度的认识，同时在编程方面也有很多的函数库，比如说IBM的CPLEX。这里只介绍Gecode的使用，当然官方文档对于Gecode已经解释的很详细了，我在这里只想梳理一下整个建立模型的步骤和稍微介绍一下Gecode。&lt;/p&gt;
&lt;h2&gt;Gecode&lt;/h2&gt;
&lt;p&gt;Gecode是一个用于解决约束问题的基于C++的函数库，覆盖了Windows，Linux，Mac三个平台。在2012年以前长期霸占着MiniZinc比赛的头名，就现在来说当然性能也不差，而且也一直有更新。关键的是，相比起CPLEX，它是免费开源的。官方主页：&lt;a href="http://www.gecode.org/"&gt;Gecode&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;问题描述&lt;/h2&gt;
&lt;p&gt;在CSP概念里，问题被表示成几个部分：变量（Variable），值域（Domain），约束（Constraint）。变量是问题模型中所有可以改变的量，可以是一组数，也可以是未知的属性，比如说香港的某一所高校。对应于每一个变量有一个相应的值域，变量的取值范围只能从值域中取。约束限制了问题里的变量的取值范围，比如说，变量$x$不能等于$y$。这三个是CSP必备的元素，Constraint Programming（CP）就是用于找出所有满足着三个元素的可能解的编程方法。对于某些问题，我们可能对于所有的可能解不感兴趣，而更想最小化某一个值，这个值是部分变量经过一些数学方程运算得出的结果，称之为目标函数（Objective）。比如说假如$x$和$y$代表房子的长和宽，我们希望最大化房子的面积，也就是$x \times y$的值。在这个问题里，我们的目标函数就是$ -(x \times y) $。需要注意的是我们关注的是目标函数的最小值，而不是最大值，因此需要求解最大值时需要取负来实现。对应于不同的编程环境，目标函数可能有不同的理解。在Gecode中，目标函数既可以求最大值也可以求最小值。&lt;/p&gt;
&lt;p&gt;举一个熟悉的例子，我们给数独建立一个CSP模型。该模型可以表述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;变量&lt;/strong&gt;：$ x_{11}，x_{12}，x_{13}，……x_{98}，x_{99} $，每一个$ x_{ij}（0&amp;lt;i，j&amp;lt;10） $表示数独问题中每一个位置的数字，其中$ i $表示行数，$ j $表示列数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;值域&lt;/strong&gt;：$ [1，9] $。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;约束&lt;/strong&gt;：$ \forall i，j，m，n \in [1，9]，i \neq m，j \neq n $
$$ \implies x_{ij} \neq x_{in}，x_{ij} \neq x_{mj}，  $$&lt;/p&gt;
&lt;p&gt;并且如果$ ({i-1 \over 3} = {m-1 \over 3}) \land ({j-1 \over 3} = {n-1 \over 3}) $，则$ x_{ij} \neq x_{mn} $。&lt;/p&gt;
&lt;p&gt;对于特定的数独问题，某些空格的值已经固定，因此还要针对该问题限制这些空格的值为固定值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;约束条件分为三个部分，第一个和第二个不等式分别表示的是数独矩阵里面行和列的元素不能重复，第三个不等式表示的是在数独矩阵中，被分割出来的一个小的$ 3 \times 3 $矩阵里面的元素也不能重复。&lt;/p&gt;
&lt;p&gt;对于同一个问题，我们可以有不同的建模方式。比如同样是数独问题，我们可以把原来的一个$ 9 \times 9 $的矩阵分解成9个大小一样的$ 3 \times 3 $矩阵，于是变量$ x_{11} $表示数字1在第一个矩阵出现的位置，变量$ x_{12} $表示数字2在第二个矩阵出现的位置，依此类推。对同一个问题的不同模型在编写程序时有可能会出现很大的性能差异，当时在处理Langford问题时不同的模型随着问题的增大，时间差距呈指数增长。所以，对于模型的选取一定要慎重考虑，而且并不是说容易理解的模型就一定优于难懂的模型，一定要考虑所用的函数库的特点。&lt;/p&gt;
&lt;h2&gt;寻找问题的解&lt;/h2&gt;
&lt;p&gt;现在我们已经有了一个问题的模型，那么如何找到这个模型的解呢？最简单的办法就是对于所有变量，我们都给它赋予满足值域的一个值，然后看看满不满足约束条件。当这个取值满足所有条件时，我们就找到了一个解，否则就从可能的取值范围里剔除掉这个情况。于是我们可以这么解决数独问题，一个一个空都填上数字，看看填满空格之后的矩阵是否满足数独问题的条件，没有满足的话就改变其中一个变量的值，或者多个变量的值，直到找到一个解或者所有解为止。这是一种最原始的方法，对于规模比较小的问题，这种方法表现还算可以，并且足够简单。但假如问题稍微增大一点，这种方法就变得力不从心了。&lt;/p&gt;
&lt;p&gt;假设我们有10个变量，每个变量有20个值可以取，那么我们需要和约束条件测试$ 20^{10} $次才能找到所有的可能解。即使现在的电脑运算速度已经非常快了，需要计算的次数对一般的电脑来说也是十分费时的。要是你不介意时间的话，当然就无所谓了。但要是有20个变量，100个变量，估计你就无法在有生之年看到所有的结果了。&lt;/p&gt;
&lt;p&gt;如何减少计算量？最直观的方法就是减少需要测试是否满足约束条件的可能解的个数。那如何保证没有经过测试的取值一定不满足约束条件，换句话说，如何保证没有一个解被遗漏掉？假如一个问题只有一个解，遗漏掉这个解的结果就是使得我们误认为这个问题没有任何解。因此，最好的方式就是从约束问题着手，我们不需要那些测试那些明显不满足约束条件的取值，把这些取值剔除掉，所需要测试的取值范围就会大大减小。&lt;/p&gt;
&lt;h2&gt;缩小取值范围&lt;/h2&gt;
&lt;p&gt;那么什么样的取值才叫做“明显不满足约束条件”呢？这就要看具体实现的权衡了。如果我们把所有不满足约束条件的取值全部剔除，那么在这一过程完成的同时，我们也找到了问题的解，因为所有剩下的取值都满足约束条件。如果我们什么都不做，那么我们就回到了前面最原始的方法，一个一个测试所有可能的取值组合。实际上，问题的关键在于有多少约束条件需要在给变量取值之前测试，有多少约束条件需要在取值之后测试。在Gecode环境里，相对应的就是代码里面将开始搜索取值的函数branch放在设置约束条件的函数之后还是之前。&lt;/p&gt;
&lt;p&gt;在这里需要定义一个概念，Consistency，即一致性。在前面讲到在剔除掉可能的取值组合时我们想保证不会将潜在的解给剔除掉，这样可以保证在缩小取值范围前后的解是一致的。所有剔除掉的取值都满足一致性的要求。在一致性的要求下，又衍生出了Node Consistency，Arc Consistency等概念，分别针对一个变量，两个变量等等。这方面已经有很多paper研究过了，现在大部分研究都关注Global Constraint的实现和定义新的Global Constraint。&lt;/p&gt;
&lt;p&gt;这个问题扩展开来可以有很多内容，实际上大部分CSP的工作都是在这里完成的。这一部分还是先暂时打住，里面涉及到的都是具体的算法了。&lt;/p&gt;
&lt;h2&gt;数独Gecode实现&lt;/h2&gt;
&lt;p&gt;在Gecode环境下，对变量，值域和约束条件的设置都在类的初始函数里面设置。初始函数必须继承自Gecode里面的一个类，Script，IntMaximizeScript等等。具体如何完整编写一个约束问题的Constraint Solver，可以参考官方文档&lt;a href="http://www.gecode.org/doc-latest/MPG.pdf"&gt;MPG&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Gecode中用IntVarArray表示数组变量，于是数独的变量被初始化为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;IntVarArray&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;建立一个矩阵数据结构来表示数独矩阵，便于对行和列分别设置约束条件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;Matrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;IntVarArray&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;mat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样对于每一行和每一列都用一个distinct constraint限定行列的元素都不重复&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// constraint of row and column&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;distinct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mat&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;distinct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mat&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;￼￼原始的数独问题我们用一个数组来表示&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sudokuArray&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;于是接下来对于第三个约束条件以及限定矩阵中部分元素的值和问题一致可以按照如下实现&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// constraint of each 3 * 3 box and the specific box&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;index1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// index/9 is the row number, index%9 is the column number&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;index2&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index2&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;rel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="no"&gt;IRT_NQ&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sudokuArray&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;rel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="no"&gt;IRT_EQ&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sudokuArray&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置了branch的参数之后，Constraint Solver的构造函数就算是完成了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// post branching&lt;/span&gt;
&lt;span class="n"&gt;branch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;INT_VAR_SIZE_MIN&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="no"&gt;INT_VAL_SPLIT_MIN&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来补全sudoku类的剩余部分，一个Solver类的编写就算是完成了。&lt;/p&gt;</summary><category term="Gecode"></category><category term="CSP"></category></entry><entry><title>第一篇日志</title><link href="http://wangdaiwei.github.io/posts/2013/Dec/23/di-pian-ri-zhi/" rel="alternate"></link><updated>2013-12-23T00:00:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2013-12-23:posts/2013/Dec/23/di-pian-ri-zhi/</id><summary type="html">&lt;h3&gt;写在前面&lt;/h3&gt;
&lt;p&gt;很早就想自己搭一个个人网站了，之前在Wix上写了一个，但是又没有动力去维护了。自从看到了论坛上的帖子有人在Github上搭了一个，一直想试一试，可惜上课的时候太忙了就没怎么开始。现在总算到了放假的时间，自己整一个感觉还挺不错的。有时间把自己之前做的乱七八糟的代码整理一下扔上来，顺便回顾一下以前的东西，希望能够有所帮助吧。至于说网站的名字，就是米兰的主场，想不出什么好名字就拿这个凑合了。&lt;/p&gt;
&lt;h3&gt;这是拿什么做的&lt;/h3&gt;
&lt;p&gt;既然是基于别人写的东西搭建的网站，原作者的文档还是放上来好一些吧。写的还是挺清楚的，不过Windows的用户就可能没有什么参考价值了。博客地址：&lt;a href="http://www.lizherui.com/pages/2013/08/17/build_blog.html"&gt;一步一步打造Geek风格的技术博客&lt;/a&gt;。同时另外一篇日志也比较有参考价值：&lt;a href="http://terriyu.info/blog/posts/2013/07/pelican-setup/"&gt;How I setup Pelican&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;近期安排&lt;/h3&gt;
&lt;p&gt;这几天在北京闲逛，准备找几个老师学长聊聊。感觉在香港待了一段时间后回来节奏有点不适应了。有机会写一点关于香港学习生活的感悟吧。&lt;/p&gt;</summary></entry></feed>