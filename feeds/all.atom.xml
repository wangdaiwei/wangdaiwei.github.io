<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Wangdaiwei's San Siro</title><link href="http://wangdaiwei.github.io/" rel="alternate"></link><link href="http://wangdaiwei.github.io/feeds/all.atom.xml" rel="self"></link><id>http://wangdaiwei.github.io/</id><updated>2014-02-20T00:00:00+08:00</updated><entry><title>ABC Path Problem Definition</title><link href="http://wangdaiwei.github.io/posts/2014/Feb/20/abc-path-problem-definition/" rel="alternate"></link><updated>2014-02-20T00:00:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2014-02-20:posts/2014/Feb/20/abc-path-problem-definition/</id><summary type="html">&lt;h1&gt;ABC Path Problem Definition&lt;/h1&gt;
&lt;p&gt;ABC Path is a game that you have to put into the N $\times$ N grid such that the total payoff of the game is maximized. If a letter is placed on the desired position, it gets 1 as payoff. Here is an example for the desired position of each letter for a $4 \times 4 $ grid.￼&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;th&gt;D&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;J&lt;/td&gt;
&lt;td&gt;K&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;And the rule is the same for other N values. It follows the alphabetic order from the upper left to the bottom right.&lt;/p&gt;
&lt;p&gt;We can model the problem with a set of 16 variables $X =$ { $x_i, j| i, j ∈ [1..4]$ }, each representing a cell of the grid. The domain of each variable $x_i,j$ is $D_i,j =$ {$ 1, 2, .., 16$ } with each value representing the letter in { $A,B,..,P$ } respectively. Let $S_i,j$ be the set of all adjacent cells of $x_i,j$. The set of constraints and the associated objective function of the problem are given as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$(x_{i,j} =1)∨ ( \bigvee _{s \in S_{i, j}} x_{i,j} =s+1 ) ,$ for $i,j∈[1..4]$&lt;/li&gt;
&lt;li&gt;$x_{i,j} \ne x_{u,v},$ for $i,j,u,v∈[1..4]$ where $¬(i=u∧j=v)$&lt;/li&gt;
&lt;li&gt;Objective: max $\sum_{i,j \in [1...4]} (x_{i,j} −(4i+j −4) == 0)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An alternative way to model the problem is to represent each letter with a variable $x_i$ , where $i ∈ [1..n2 ]$ and the domain of each variable $x_i$ is $D_i =$ { $1, 2, ..., n2$ } representing the position of the corresponding letter in the grid.&lt;/p&gt;
&lt;p&gt;The Gecode implementation has been uploaded to my github repository. You can see the source code at website &lt;a href="https://github.com/wangdaiwei/gecode"&gt;wangdaiwei/gecode&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The program should be run as following command in Mac OSX:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;abc_path&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="n"&gt;mod&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here &lt;em&gt;mod&lt;/em&gt; stands for the model you choose. The value is from 1 to 2, which represents the memtioned models. The last parameter defines the size of ABC Path problem.&lt;/p&gt;</summary><category term="CSP"></category></entry><entry><title>N-Queens Problem Definition</title><link href="http://wangdaiwei.github.io/posts/2014/Feb/20/n-queens-problem-definition/" rel="alternate"></link><updated>2014-02-20T00:00:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2014-02-20:posts/2014/Feb/20/n-queens-problem-definition/</id><summary type="html">&lt;h1&gt;N Queens Problem Definition&lt;/h1&gt;
&lt;p&gt;N-Queens problem is defined as: place n queens on an $n × n$ chess board so that the queens do not attack each other. Now, we rotate the board clockwisely by 45 degrees as shown in following picture, and use a variable to denote the queen partition (if any) for each row (a diagonal in the original board).&lt;/p&gt;
&lt;p&gt;&lt;img alt="Figure 1" src="https://raw.github.com/wangdaiwei/gecode/master/queens.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Thus the variables are $y_{1-n}, y_{2-n},..., y_{0},..., y_{n-2}, y_{n-1}.$ While each variable takes values according to the new coordinate system, we use the value $−n$ to denote that there are no queens on a particular row. The domain of each variable $y_i$ is thus $ D_i = $ { $|i|+1,|i|+3,...,2n−|i|−1$ } $∪$ {$−n$} for $i ∈ [1−n,n−1] $. The set of constraints are given as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for $i∈[1−n,n−1]$: $\sum_i(y_i \ne−n)=n$&lt;/li&gt;
&lt;li&gt;for $i∈[1−n,n−1]$ and $j∈[1,2n−1]: \sum_i(y_i =j)≤1$&lt;/li&gt;
&lt;li&gt;for $i,j∈[1−n,n−1]$ and $i \ne j:|y_i−y_j| \ne |i−j|$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The model is modeled in three ways: arithmetic constraint, tuple sets and DFA.&lt;/p&gt;
&lt;p&gt;The Gecode implementation has been uploaded to my github repository. You can see the source code at website &lt;a href="https://github.com/wangdaiwei/gecode"&gt;wangdaiwei/gecode&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The program should be run as following command in Mac OSX:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;queens&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="n"&gt;mod&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here &lt;em&gt;mod&lt;/em&gt; stands for the model you choose. The value is from 1 to 3. The last parameter defines the size of N-Queens problem.&lt;/p&gt;</summary><category term="CSP"></category></entry><entry><title>Sudoku Problem Definition</title><link href="http://wangdaiwei.github.io/posts/2014/Feb/20/sudoku-problem-definition/" rel="alternate"></link><updated>2014-02-20T00:00:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2014-02-20:posts/2014/Feb/20/sudoku-problem-definition/</id><summary type="html">&lt;h1&gt;Sudoku Problem Definition&lt;/h1&gt;
&lt;p&gt;Sudoku is a puzzle that requires players to complete a partially filled 9 × 9 grid with digits 1 to 9 such that each row, each column and each of the nine 3 × 3 boxes (shown in Figure 1 in thick border lines) contain different digits.&lt;/p&gt;
&lt;p&gt;￼￼￼The Gecode implementation has hardcoded the sudoku problem. You can modify the sudokuArray in order to solve different sudoku problems.&lt;/p&gt;
&lt;p&gt;The Gecode implementation has been uploaded to my github repository. You can see the source code at website &lt;a href="https://github.com/wangdaiwei/gecode"&gt;wangdaiwei/gecode&lt;/a&gt;.&lt;/p&gt;</summary><category term="CSP"></category></entry><entry><title>理解Hadoop和MapReduce</title><link href="http://wangdaiwei.github.io/posts/2014/Jan/25/li-jie-hadoophe-mapreduce/" rel="alternate"></link><updated>2014-01-25T00:00:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2014-01-25:posts/2014/Jan/25/li-jie-hadoophe-mapreduce/</id><summary type="html">&lt;h2&gt;为什么需要用到Hadoop&lt;/h2&gt;
&lt;p&gt;Hadoop是Apache开源基金会下的一个项目，针对处理大数据的特性设计的分布式编程模型工具。Hadoop的核心思想来源于Google的MapReduce和Google File System（GFS）。通俗来讲，就是将处理的问题分为两个子问题，一个负责将问题分割成一个一个小的部分，另一个负责将前一个步骤的每一部分都合并在一起。&lt;/p&gt;
&lt;p&gt;最常见的例子就是单词统计。假设我们需要统计一个文档里的单词，最简单的方式就是用一个dictionary或者map来存储一个key-value对。一旦发现一个新的单词，我们就在这个dictionary里面添加一个条目，value设为1。如果这个单词已经存在，那么取出这个key对应的value，将其加1。这种方式对于一个小的文档来说固然合适，但如果我们处理的是一个TB，PB级别的数据呢？如果我们想在1秒钟之内就处理完这些数据？这就需要用到分布式处理了，也就是多台机器同时运算。对于数单词这样一个简单的工作，要解决的就是如何分配任务，每一台机器需要处理文档的哪个部分，以及如何将这些结果整合在一起。有了这样的思想，我们可以给这两个部分的工作分配给两个模块，一个是mapper，一个是reducer。mapper负责把问题分割成很小的一部分，每一部分都会产生一个问题的输出；reducer负责把所有若干个mapper产生的输出汇总，再计算出所需的输出。由于这种模型涉及到的数据量都比较大，而建立在大数据上的数据处理一般来说都相对比较简单，因此将这种模型一般化，使用户只需要关注mapper和reducer的具体实现，而不用考虑异常处理，问题分割等等细节问题，这就是Hadoop需要解决的问题。&lt;/p&gt;
&lt;p&gt;但是，并不是所有问题都适合用MapReduce模型解决，比如说PageRank。当问题涉及到图结构的时候，一个很普遍的现象就是活跃节点和不活跃节点差异非常明显。比如说Yahoo网页的PageRank值要计算很多次才能收敛，因为它链接的网页实在是太多了。而小一点的网站可能一下子就收敛了，因为其本身链接的网站并不多，也并没有很高的影响力。而且在图问题中，绝大部分的节点都是不活跃的，也就是说可能整个MapReduce计算一次，只有少数几个节点的值发生了变化，这严重影响到了处理时间。Google针对这个问题提出了Pregel模型，GraphLab就是参考这个模型实现的，相关的论文里面可以看出在PageRank和三角形计数算法上GraphLab完胜基于MapReduce的Hadoop。&lt;/p&gt;
&lt;h2&gt;理解Mapper和Reducer&lt;/h2&gt;
&lt;p&gt;如果只从输入输出来看，mapper和reducer的输入输出都是一个key-valud对。当然，具体实现来说key和value并不是必须的，比如说统计所有文档的单词数，mapper的输入就可以是key：文件名，value：文件内容，文件名在这里不需要用到。&lt;/p&gt;
&lt;p&gt;对于数单词这个问题，mapper需要做的就是把自己负责的那部分文档的单词都统计出来，输出key-value对。这里的key就是单词，value就是1，代表的含义就是在这部分的文档中这个单词出现了1次。当然，也可以在mapper里面就把所有重复的单词都统计一次，汇总之后再设为这个单词key的value。而reducer就会收到mapper的单词key-value对。假如一开始mapper输入的文档内容是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么mapper的输出就是如下形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时reducer接收到的输入是按照key排列号的，因此实际上reducer的输入是如下的顺序输入的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;于是实际上reducer可以这么写，这里用伪代码实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
    &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;foreach&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;vals&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
    &lt;span class="n"&gt;emit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样得到的最终reducer的输出应该是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;具体实现&lt;/h2&gt;
&lt;p&gt;鉴于网上hadoop的教程都比较多，就不在这里写出来了，用Python实现的可以参考&lt;a href="http://www.michael-noll.com/tutorials/writing-an-hadoop-mapreduce-program-in-python/"&gt;Writing an Hadoop MapReduce Program in Python&lt;/a&gt;，还有用Java实现的例子：&lt;a href="http://www.cnblogs.com/xia520pi/archive/2012/06/04/2534533.html"&gt;Hadoop集群（第9期）_MapReduce初级案例&lt;/a&gt;。&lt;/p&gt;</summary><category term="Mapreduce"></category></entry><entry><title>Constraint Satisfaction Problem</title><link href="http://wangdaiwei.github.io/posts/2014/Jan/07/constraint-satisfaction-problem/" rel="alternate"></link><updated>2014-01-07T00:00:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2014-01-07:posts/2014/Jan/07/constraint-satisfaction-problem/</id><summary type="html">&lt;h2&gt;CSP概述&lt;/h2&gt;
&lt;p&gt;作为对学了一个学期的内容的总结，在这里稍微介绍一下Constraint Satisfaction Problem（CSP）吧。这个题目我也不知道中文叫做什么，也许叫做有约束问题解决模型比较合适。虽然我没有学过数学建模，但或许他们之间是比较类似的，CSP的中心思想就是针对一个特定的问题建立模型，然后解决它。解决问题的具体实现就叫做Constraint Solver（约束处理机）。我认为这个方法还是很实际的，它可以帮助我们快速建立起对一个问题的数学角度的认识，同时在编程方面也有很多的函数库，比如说IBM的CPLEX。这里只介绍Gecode的使用，当然官方文档对于Gecode已经解释的很详细了，我在这里只想梳理一下整个建立模型的步骤和稍微介绍一下Gecode。&lt;/p&gt;
&lt;h2&gt;Gecode&lt;/h2&gt;
&lt;p&gt;Gecode是一个用于解决约束问题的基于C++的函数库，覆盖了Windows，Linux，Mac三个平台。在2012年以前长期霸占着MiniZinc比赛的头名，就现在来说当然性能也不差，而且也一直有更新。关键的是，相比起CPLEX，它是免费开源的。官方主页：&lt;a href="http://www.gecode.org/"&gt;Gecode&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;问题描述&lt;/h2&gt;
&lt;p&gt;在CSP概念里，问题被表示成几个部分：变量（Variable），值域（Domain），约束（Constraint）。变量是问题模型中所有可以改变的量，可以是一组数，也可以是未知的属性，比如说香港的某一所高校。对应于每一个变量有一个相应的值域，变量的取值范围只能从值域中取。约束限制了问题里的变量的取值范围，比如说，变量$x$不能等于$y$。这三个是CSP必备的元素，Constraint Programming（CP）就是用于找出所有满足着三个元素的可能解的编程方法。对于某些问题，我们可能对于所有的可能解不感兴趣，而更想最小化某一个值，这个值是部分变量经过一些数学方程运算得出的结果，称之为目标函数（Objective）。比如说假如$x$和$y$代表房子的长和宽，我们希望最大化房子的面积，也就是$x \times y$的值。在这个问题里，我们的目标函数就是$ -(x \times y) $。需要注意的是我们关注的是目标函数的最小值，而不是最大值，因此需要求解最大值时需要取负来实现。对应于不同的编程环境，目标函数可能有不同的理解。在Gecode中，目标函数既可以求最大值也可以求最小值。&lt;/p&gt;
&lt;p&gt;举一个熟悉的例子，我们给数独建立一个CSP模型。该模型可以表述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;变量&lt;/strong&gt;：$ x_{11}，x_{12}，x_{13}，……x_{98}，x_{99} $，每一个$ x_{ij}（0&amp;lt;i，j&amp;lt;10） $表示数独问题中每一个位置的数字，其中$ i $表示行数，$ j $表示列数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;值域&lt;/strong&gt;：$ [1，9] $。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;约束&lt;/strong&gt;：$ \forall i，j，m，n \in [1，9]，i \neq m，j \neq n $
$$ \implies x_{ij} \neq x_{in}，x_{ij} \neq x_{mj}，  $$&lt;/p&gt;
&lt;p&gt;并且如果$ ({i-1 \over 3} = {m-1 \over 3}) \land ({j-1 \over 3} = {n-1 \over 3}) $，则$ x_{ij} \neq x_{mn} $。&lt;/p&gt;
&lt;p&gt;对于特定的数独问题，某些空格的值已经固定，因此还要针对该问题限制这些空格的值为固定值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;约束条件分为三个部分，第一个和第二个不等式分别表示的是数独矩阵里面行和列的元素不能重复，第三个不等式表示的是在数独矩阵中，被分割出来的一个小的$ 3 \times 3 $矩阵里面的元素也不能重复。&lt;/p&gt;
&lt;p&gt;对于同一个问题，我们可以有不同的建模方式。比如同样是数独问题，我们可以把原来的一个$ 9 \times 9 $的矩阵分解成9个大小一样的$ 3 \times 3 $矩阵，于是变量$ x_{11} $表示数字1在第一个矩阵出现的位置，变量$ x_{12} $表示数字2在第二个矩阵出现的位置，依此类推。对同一个问题的不同模型在编写程序时有可能会出现很大的性能差异，当时在处理Langford问题时不同的模型随着问题的增大，时间差距呈指数增长。所以，对于模型的选取一定要慎重考虑，而且并不是说容易理解的模型就一定优于难懂的模型，一定要考虑所用的函数库的特点。&lt;/p&gt;
&lt;h2&gt;寻找问题的解&lt;/h2&gt;
&lt;p&gt;现在我们已经有了一个问题的模型，那么如何找到这个模型的解呢？最简单的办法就是对于所有变量，我们都给它赋予满足值域的一个值，然后看看满不满足约束条件。当这个取值满足所有条件时，我们就找到了一个解，否则就从可能的取值范围里剔除掉这个情况。于是我们可以这么解决数独问题，一个一个空都填上数字，看看填满空格之后的矩阵是否满足数独问题的条件，没有满足的话就改变其中一个变量的值，或者多个变量的值，直到找到一个解或者所有解为止。这是一种最原始的方法，对于规模比较小的问题，这种方法表现还算可以，并且足够简单。但假如问题稍微增大一点，这种方法就变得力不从心了。&lt;/p&gt;
&lt;p&gt;假设我们有10个变量，每个变量有20个值可以取，那么我们需要和约束条件测试$ 20^{10} $次才能找到所有的可能解。即使现在的电脑运算速度已经非常快了，需要计算的次数对一般的电脑来说也是十分费时的。要是你不介意时间的话，当然就无所谓了。但要是有20个变量，100个变量，估计你就无法在有生之年看到所有的结果了。&lt;/p&gt;
&lt;p&gt;如何减少计算量？最直观的方法就是减少需要测试是否满足约束条件的可能解的个数。那如何保证没有经过测试的取值一定不满足约束条件，换句话说，如何保证没有一个解被遗漏掉？假如一个问题只有一个解，遗漏掉这个解的结果就是使得我们误认为这个问题没有任何解。因此，最好的方式就是从约束问题着手，我们不需要那些测试那些明显不满足约束条件的取值，把这些取值剔除掉，所需要测试的取值范围就会大大减小。&lt;/p&gt;
&lt;h2&gt;缩小取值范围&lt;/h2&gt;
&lt;p&gt;那么什么样的取值才叫做“明显不满足约束条件”呢？这就要看具体实现的权衡了。如果我们把所有不满足约束条件的取值全部剔除，那么在这一过程完成的同时，我们也找到了问题的解，因为所有剩下的取值都满足约束条件。如果我们什么都不做，那么我们就回到了前面最原始的方法，一个一个测试所有可能的取值组合。实际上，问题的关键在于有多少约束条件需要在给变量取值之前测试，有多少约束条件需要在取值之后测试。在Gecode环境里，相对应的就是代码里面将开始搜索取值的函数branch放在设置约束条件的函数之后还是之前。&lt;/p&gt;
&lt;p&gt;在这里需要定义一个概念，Consistency，即一致性。在前面讲到在剔除掉可能的取值组合时我们想保证不会将潜在的解给剔除掉，这样可以保证在缩小取值范围前后的解是一致的。所有剔除掉的取值都满足一致性的要求。在一致性的要求下，又衍生出了Node Consistency，Arc Consistency等概念，分别针对一个变量，两个变量等等。这方面已经有很多paper研究过了，现在大部分研究都关注Global Constraint的实现和定义新的Global Constraint。&lt;/p&gt;
&lt;p&gt;这个问题扩展开来可以有很多内容，实际上大部分CSP的工作都是在这里完成的。这一部分还是先暂时打住，里面涉及到的都是具体的算法了。&lt;/p&gt;
&lt;h2&gt;数独Gecode实现&lt;/h2&gt;
&lt;p&gt;在Gecode环境下，对变量，值域和约束条件的设置都在类的初始函数里面设置。初始函数必须继承自Gecode里面的一个类，Script，IntMaximizeScript等等。具体如何完整编写一个约束问题的Constraint Solver，可以参考官方文档&lt;a href="http://www.gecode.org/doc-latest/MPG.pdf"&gt;MPG&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Gecode中用IntVarArray表示数组变量，于是数独的变量被初始化为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;IntVarArray&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;建立一个矩阵数据结构来表示数独矩阵，便于对行和列分别设置约束条件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;Matrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;IntVarArray&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;mat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样对于每一行和每一列都用一个distinct constraint限定行列的元素都不重复&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// constraint of row and column&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;distinct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mat&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;distinct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mat&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;￼￼原始的数独问题我们用一个数组来表示&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sudokuArray&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;于是接下来对于第三个约束条件以及限定矩阵中部分元素的值和问题一致可以按照如下实现&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// constraint of each 3 * 3 box and the specific box&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;index1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// index/9 is the row number, index%9 is the column number&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;index2&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index2&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;rel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="no"&gt;IRT_NQ&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sudokuArray&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;rel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="no"&gt;IRT_EQ&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sudokuArray&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置了branch的参数之后，Constraint Solver的构造函数就算是完成了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// post branching&lt;/span&gt;
&lt;span class="n"&gt;branch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;INT_VAR_SIZE_MIN&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="no"&gt;INT_VAL_SPLIT_MIN&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来补全sudoku类的剩余部分，一个Solver类的编写就算是完成了。&lt;/p&gt;</summary><category term="Gecode"></category><category term="CSP"></category></entry><entry><title>第一篇日志</title><link href="http://wangdaiwei.github.io/posts/2013/Dec/23/di-pian-ri-zhi/" rel="alternate"></link><updated>2013-12-23T00:00:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2013-12-23:posts/2013/Dec/23/di-pian-ri-zhi/</id><summary type="html">&lt;h3&gt;写在前面&lt;/h3&gt;
&lt;p&gt;很早就想自己搭一个个人网站了，之前在Wix上写了一个，但是又没有动力去维护了。自从看到了论坛上的帖子有人在Github上搭了一个，一直想试一试，可惜上课的时候太忙了就没怎么开始。现在总算到了放假的时间，自己整一个感觉还挺不错的。有时间把自己之前做的乱七八糟的代码整理一下扔上来，顺便回顾一下以前的东西，希望能够有所帮助吧。至于说网站的名字，就是米兰的主场，想不出什么好名字就拿这个凑合了。&lt;/p&gt;
&lt;h3&gt;这是拿什么做的&lt;/h3&gt;
&lt;p&gt;既然是基于别人写的东西搭建的网站，原作者的文档还是放上来好一些吧。写的还是挺清楚的，不过Windows的用户就可能没有什么参考价值了。博客地址：&lt;a href="http://www.lizherui.com/pages/2013/08/17/build_blog.html"&gt;一步一步打造Geek风格的技术博客&lt;/a&gt;。同时另外一篇日志也比较有参考价值：&lt;a href="http://terriyu.info/blog/posts/2013/07/pelican-setup/"&gt;How I setup Pelican&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;近期安排&lt;/h3&gt;
&lt;p&gt;这几天在北京闲逛，准备找几个老师学长聊聊。感觉在香港待了一段时间后回来节奏有点不适应了。有机会写一点关于香港学习生活的感悟吧。&lt;/p&gt;</summary></entry></feed>