<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Wangdaiwei's San Siro</title><link href="http://wangdaiwei.github.io/" rel="alternate"></link><link href="http://wangdaiwei.github.io/feeds/tech.atom.xml" rel="self"></link><id>http://wangdaiwei.github.io/</id><updated>2014-06-23T23:30:00+08:00</updated><entry><title>iOS推送机制的隐患</title><link href="http://wangdaiwei.github.io/posts/2014/Jun/23/iostui-song-ji-zhi-de-yin-huan/" rel="alternate"></link><updated>2014-06-23T23:30:00+08:00</updated><author><name>wangdaiwei</name></author><id>tag:wangdaiwei.github.io,2014-06-23:posts/2014/Jun/23/iostui-song-ji-zhi-de-yin-huan/</id><summary type="html">&lt;p&gt;最近在研究iOS的推送系统，虽然配置起来稍微麻烦了一些，但是实现的原理并不复杂。简单来讲，就是通过app向APNS（Apple Push Notification Service）发送一个注册的请求，等到APNS同意之后便会发回设备的ID。在这个过程中，用户是可以一开始就选择是否接受推送通知的，如果用户不同意接收推送通知的话那么APNS也会收到用户的选择而不再发送推送通知，直到用户修改设置里面的选项。&lt;/p&gt;
&lt;p&gt;现在的一个问题就在于，推送通知在app没有打开的情况（或者打开以后进入后台）下，是iOS系统自己处理的。这就造成什么问题呢？应用在没有使用的情况下，是没有办法处理接收到的推送通知的。比如说一个新闻客户端，如果想在收到推送通知的时候弹出提示框显示最新的新闻，这是无法办到的，除非用户在设置里面将推送的显示修改成提示框形式。这样有一个好处就是，应用程序无需关注程序没有打开情况下对推送的信息的处理，同时也节省了系统的资源，不需要每一个程序都监视推送信息的接收。&lt;/p&gt;
&lt;p&gt;直到现在都一切正常，没有什么大问题。但是最近突然发现了一个很致命的安全隐患，就是&lt;strong&gt;假如用户卸载了app并且重新安装回去，即使用户不打开app也能收到之前用户的推送信息&lt;/strong&gt;。这代表什么呢？假使用户卸载了应用程序但是没有删除用户信息，那么接下来的用户如果安装了同一个应用并且并没有登录进应用程序，那么他照样可以收到&lt;strong&gt;之前用户&lt;/strong&gt;的推送信息。这是什么原因呢？iOS在卸载用户程序的时候不会告诉给应用程序提供者，因此假如该用户没有在新的设备上登录的话，那么应用程序提供者将会继续发送该用户的推送信息给该设备。当设备重新安装上app的时候，就会接收到之前用户的推送信息，只要这位用户还没有登录自己的账号。&lt;/p&gt;
&lt;p&gt;我在WhatsApp上测试了一下，这种情况的确是存在的。WhatApp每次卸载之后都要重新安装，但只要重新安装之后不登陆新的账号，那么之前用户的推送信息都能全部收到。虽然说这种情况并不常见，但是还是有一定的风险的，以后如果使用app的时候在卸载程序的时候最好都记得把登录信息删除掉。如果忘记删除了，其实也不太要紧，可以有两个选择：一是重新登录一次再删除掉登录信息或者在新的设备上登录，二是保证设备在删除该app后24小时内没有重新安装回去，在这种情况下设备也不会接收到推送信息，实测有效。不过突然想到要是变成了24小时之后收不到推送信息，然后再把手机的时间拨回去会怎么样，因为只是将手机的时间往后拨就能模拟删除应用24小时了。有机会尝试一下吧。&lt;/p&gt;
&lt;p&gt;Android倒是没有这样的问题，因为推送信息是交由app自己处理的。因此只要不是程序故意想把推送信息显示出来，只要app检测到用户没有登录便不把推送信息显示出来即可。Windows Phone倒是不太清楚，有机会试一试吧。&lt;/p&gt;</summary><category term="iOS"></category></entry></feed>